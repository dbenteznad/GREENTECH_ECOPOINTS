import {
  __commonJS
} from "./chunk-GKWPUQBP.js";

// node_modules/rivescript/src/utils.js
var require_utils = __commonJS({
  "node_modules/rivescript/src/utils.js"(exports2) {
    "use strict";
    exports2.strip = function(text) {
      text = text.replace(/^[\s\t]+/, "").replace(/[\s\t]+$/, "").replace(/[\x0D\x0A]+/, "");
      return text;
    };
    exports2.trim = function(text) {
      text = text.replace(/^[\x0D\x0A\s\t]+/, "").replace(/[\x0D\x0A\s\t]+$/, "");
      return text;
    };
    exports2.extend = function(a, b) {
      var attr, results, value;
      results = [];
      for (attr in b) {
        value = b[attr];
        if (!b.hasOwnProperty(attr)) {
          continue;
        }
        results.push(a[attr] = value);
      }
      return results;
    };
    exports2.word_count = function(trigger, all) {
      var i, len, wc, word, words;
      words = [];
      if (all) {
        words = trigger.split(/\s+/);
      } else {
        words = trigger.split(/[\s\*\#_\|]+/);
      }
      wc = 0;
      for (i = 0, len = words.length; i < len; i++) {
        word = words[i];
        if (word.length > 0) {
          wc++;
        }
      }
      return wc;
    };
    exports2.stripNasties = function(string, utf8) {
      if (utf8) {
        string = string.replace(/[\\<>]+/g, "");
        return string;
      }
      string = string.replace(/[^A-Za-z0-9 ]/g, "");
      return string;
    };
    exports2.quotemeta = function(string) {
      var char, i, len, unsafe;
      unsafe = "\\.+*?[^]$(){}=!<>|:".split("");
      for (i = 0, len = unsafe.length; i < len; i++) {
        char = unsafe[i];
        string = string.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
      }
      return string;
    };
    exports2.isAtomic = function(trigger) {
      var i, len, ref, special;
      ref = ["*", "#", "_", "(", "[", "<", "@"];
      for (i = 0, len = ref.length; i < len; i++) {
        special = ref[i];
        if (trigger.indexOf(special) > -1) {
          return false;
        }
      }
      return true;
    };
    exports2.stringFormat = function(type, string) {
      var first, i, len, result, word, words;
      if (type === "uppercase") {
        return string.toUpperCase();
      } else if (type === "lowercase") {
        return string.toLowerCase();
      } else if (type === "sentence") {
        string += "";
        first = string.charAt(0).toUpperCase();
        return first + string.substring(1);
      } else if (type === "formal") {
        words = string.split(/\s+/);
        result = [];
        for (i = 0, len = words.length; i < len; i++) {
          word = words[i];
          first = word.charAt(0).toUpperCase();
          result.push(first + word.substring(1));
        }
        return result.join(" ");
      }
      return content;
    };
    exports2.parseCallArgs = function(str) {
      var buff, c, doubleQuoteRe, flushBuffer, i, insideAString, len, result, spaceRe;
      result = [];
      buff = "";
      insideAString = false;
      spaceRe = /\s/ig;
      doubleQuoteRe = /"/ig;
      flushBuffer = function() {
        if (buff.length !== 0) {
          result.push(buff);
        }
        return buff = "";
      };
      for (i = 0, len = str.length; i < len; i++) {
        c = str[i];
        if (c.match(spaceRe) && !insideAString) {
          flushBuffer();
          continue;
        }
        if (c.match(doubleQuoteRe)) {
          if (insideAString) {
            flushBuffer();
          }
          insideAString = !insideAString;
          continue;
        }
        buff += c;
      }
      flushBuffer();
      return result;
    };
    exports2.clone = function(obj) {
      var copy, key;
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      copy = obj.constructor();
      for (key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }
        copy[key] = exports2.clone(obj[key]);
      }
      return copy;
    };
    exports2.nIndexOf = function(string, match, index) {
      return string.split(match, index).join(match).length;
    };
  }
});

// node_modules/rivescript/src/parser.js
var require_parser = __commonJS({
  "node_modules/rivescript/src/parser.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var RS_VERSION = "2.0";
    var Parser = class Parser {
      constructor(master2) {
        var self = this;
        self.master = master2;
        self.strict = master2._strict;
        self.utf8 = master2._utf8;
      }
      // Proxy functions
      say(message) {
        return this.master.say(message);
      }
      warn(message, filename, lineno) {
        return this.master.warn(message, filename, lineno);
      }
      /**
      	object parse (string filename, string code[, func onError])
      
      	Read and parse a RiveScript document. Returns a data structure that
      	represents all of the useful contents of the document, in this format:
      
      	```javascript
      	{
      	  "begin": { // "begin" data
      	    "global": {}, // ! global vars
      	    "var": {},    // ! bot vars
      	    "sub": {},    // ! sub substitutions
      	    "person": {}, // ! person substitutions
      	    "array": {},  // ! array lists
      	  },
      	  "topics": { // main reply data
      	    "random": { // (topic name)
      	      "includes": {}, // included topics
      	      "inherits": {}, // inherited topics
      	      "triggers": [ // array of triggers
      	        {
      	          "trigger": "hello bot",
      	          "reply": [], // array of replies
      	          "condition": [], // array of conditions
      	          "redirect": "",  // @ redirect command
      	          "previous": null, // % previous command
      	        },
      	        ...
      	      ]
      	    }
      	  },
      	  "objects": [ // parsed object macros
      	    {
      	      "name": "",     // object name
      	      "language": "", // programming language
      	      "code": [],     // object source code (in lines)
      	    }
      	  ]
      	}
      	```
      
      	onError function receives: `(err string[, filename str, line_no int])`
      	*/
      parse(filename, code2, onError) {
        var self = this;
        if (onError === void 0) {
          onError = function(err, filename2, lineno) {
            self.warn(err, filename2, lineno);
          };
        }
        let ast = {
          begin: {
            global: {},
            var: {},
            sub: {},
            person: {},
            array: {}
          },
          topics: {},
          objects: []
        };
        let topic = "random";
        let comment = false;
        let inobj = false;
        let objName = "";
        let objLang = "";
        let objBuf = [];
        let curTrig = null;
        let lastcmd = "";
        let isThat = null;
        let localOptions = {
          concat: self.master._concat != null ? self.master._concat : "none"
        };
        const concatModes = {
          none: "",
          newline: "\n",
          space: " "
        };
        let lines = code2.split("\n");
        for (let lp = 0, len = lines.length; lp < len; lp++) {
          let line = lines[lp];
          let lineno = lp + 1;
          line = utils.strip(line);
          if (line.length === 0) {
            continue;
          }
          if (inobj) {
            if (line.indexOf("< object") > -1 || line.indexOf("<object") > -1) {
              if (objName.length > 0) {
                ast.objects.push({
                  name: objName,
                  language: objLang,
                  code: objBuf
                });
              }
              objName = objLang = "";
              objBuf = [];
              inobj = false;
            } else {
              objBuf.push(line);
            }
            continue;
          }
          if (line.indexOf("//") === 0) {
            continue;
          } else if (line.indexOf("#") === 0) {
            self.warn("Using the # symbol for comments is deprecated", filename, lineno);
            continue;
          } else if (line.indexOf("/*") === 0) {
            if (line.indexOf("*/") > -1) {
              continue;
            }
            comment = true;
            continue;
          } else if (line.indexOf("*/") > -1) {
            comment = false;
            continue;
          }
          if (comment) {
            continue;
          }
          if (line.length < 2) {
            self.warn(`Weird single-character line '${line}' found (in topic ${topic})`, filename, lineno);
            continue;
          }
          let cmd = line.substring(0, 1);
          line = utils.strip(line.substring(1));
          if (line.indexOf(" //") > -1) {
            line = utils.strip(line.split(" //")[0]);
          }
          if (cmd === "?") {
            let variants = [
              line,
              `[*]${line}[*]`,
              `*${line}*`,
              `[*]${line}*`,
              `*${line}[*]`,
              `${line}*`,
              `*${line}`
            ];
            cmd = "+";
            line = "(" + variants.join("|") + ")";
            self.say(`Rewrote ?Keyword as +Trigger: ${line}`);
          }
          if (self.master._forceCase === true && cmd === "+") {
            line = line.toLowerCase();
          }
          let syntaxError = self.checkSyntax(cmd, line);
          if (syntaxError !== "") {
            if (self.strict) {
              onError.call(null, `Syntax error: ${syntaxError} at ${filename} line ${lineno} near ${cmd} ${line}`);
            } else {
              self.warn(`Syntax error: ${syntaxError} at ${filename} line ${lineno} near ${cmd} ${line} (in topic ${topic})`);
            }
          }
          if (cmd === "+") {
            isThat = null;
          }
          self.say(`Cmd: ${cmd}; line: ${line}`);
          for (let li = lp + 1, len2 = lines.length; li < len2; li++) {
            let lookahead = lines[li];
            lookahead = utils.strip(lookahead);
            if (lookahead.length < 2) {
              continue;
            }
            let lookCmd = lookahead.substring(0, 1);
            lookahead = utils.strip(lookahead.substring(1));
            if (lookCmd !== "%" && lookCmd !== "^") {
              break;
            }
            if (lookahead.length === 0) {
              break;
            }
            self.say(`	Lookahead ${li}: ${lookCmd} ${lookahead}`);
            if (cmd === "+") {
              if (lookCmd === "%") {
                isThat = lookahead;
                break;
              } else {
                isThat = null;
              }
            }
            if (cmd === "!") {
              if (lookCmd === "^") {
                line += `<crlf>${lookahead}`;
              }
              continue;
            }
            if (cmd !== "^" && lookCmd !== "%") {
              if (lookCmd === "^") {
                if (concatModes[localOptions.concat] !== void 0) {
                  line += concatModes[localOptions.concat] + lookahead;
                } else {
                  line += lookahead;
                }
              } else {
                break;
              }
            }
          }
          var type = "", name2 = "";
          switch (cmd) {
            case "!":
              let halves = line.split("=", 2);
              let left = utils.strip(halves[0]).split(" ");
              let value = "";
              name2 = "";
              type = "";
              if (halves.length === 2) {
                value = utils.strip(halves[1]);
              }
              if (left.length >= 1) {
                type = utils.strip(left[0]);
                if (left.length >= 2) {
                  left.shift();
                  name2 = utils.strip(left.join(" "));
                }
              }
              if (type !== "array") {
                value = value.replace(/<crlf>/g, "");
              }
              if (type === "version") {
                if (parseFloat(value) > parseFloat(RS_VERSION)) {
                  onError.call(null, `Unsupported RiveScript version. We only support ${RS_VERSION} at ${filename} line ${lineno}`, filename, lineno);
                  return ast;
                }
                continue;
              }
              if (name2.length === 0) {
                self.warn("Undefined variable name", filename, lineno);
                continue;
              }
              if (value.length === 0) {
                self.warn("Undefined variable value", filename, lineno);
                continue;
              }
              switch (type) {
                case "local":
                  self.say(`	Set local parser option ${name2} = ${value}`);
                  localOptions[name2] = value;
                  break;
                case "global":
                  self.say(`	Set global ${name2} = ${value}`);
                  ast.begin.global[name2] = value;
                  break;
                case "var":
                  self.say(`	Set bot variable ${name2} = ${value}`);
                  ast.begin.var[name2] = value;
                  break;
                case "array":
                  if (value === "<undef>") {
                    ast.begin.array[name2] = "<undef>";
                    continue;
                  }
                  let parts = value.split("<crlf>");
                  let fields2 = [];
                  for (let l = 0, len2 = parts.length; l < len2; l++) {
                    let val = parts[l];
                    if (val.indexOf("|") > -1) {
                      fields2.push.apply(fields2, val.split("|"));
                    } else {
                      fields2.push.apply(fields2, val.split(" "));
                    }
                  }
                  for (let i = 0, len3 = fields2.length; i < len3; i++) {
                    let field = fields2[i];
                    fields2[i] = fields2[i].replace(/\\s/ig, " ");
                  }
                  fields2 = fields2.filter(function(val) {
                    return val !== "";
                  });
                  self.say(`	Set array ${name2} = ${JSON.stringify(fields2)}`);
                  ast.begin.array[name2] = fields2;
                  break;
                case "sub":
                  self.say(`	Set substitution ${name2} = ${value}`);
                  ast.begin.sub[name2] = value;
                  break;
                case "person":
                  self.say(`	Set person substitution ${name2} = ${value}`);
                  ast.begin.person[name2] = value;
                  break;
                default:
                  self.warn(`Unknown definition type ${type}`, filename, lineno);
              }
              break;
            case ">":
              let temp = utils.strip(line).split(" ");
              type = temp.shift();
              name2 = "";
              let fields = [];
              if (temp.length > 0) {
                name2 = temp.shift();
              }
              if (temp.length > 0) {
                fields = temp;
              }
              switch (type) {
                case "begin":
                case "topic":
                  if (type === "begin") {
                    self.say("Found the BEGIN block.");
                    type = "topic";
                    name2 = "__begin__";
                  }
                  if (self.master._forceCase === true) {
                    name2 = name2.toLowerCase();
                  }
                  self.say(`Set topic to ${name2}`);
                  curTrig = null;
                  topic = name2;
                  self.initTopic(ast.topics, topic);
                  let mode = "";
                  if (fields.length >= 2) {
                    for (let n = 0, len4 = fields.length; n < len4; n++) {
                      let field = fields[n];
                      if (field === "includes" || field === "inherits") {
                        mode = field;
                      } else if (mode !== "") {
                        ast.topics[topic][mode][field] = 1;
                      }
                    }
                  }
                  break;
                case "object":
                  let lang = "";
                  if (fields.length > 0) {
                    lang = fields[0].toLowerCase();
                  }
                  if (lang === "") {
                    self.warn("Trying to parse unknown programming language", filename, lineno);
                    lang = "javascript";
                  }
                  objName = name2;
                  objLang = lang;
                  objBuf = [];
                  inobj = true;
                  break;
                default:
                  self.warn(`Unknown label type ${type}`, filename, lineno);
              }
              break;
            case "<":
              type = line;
              if (type === "begin" || type === "topic") {
                self.say("	End the topic label.");
                topic = "random";
              } else if (type === "object") {
                self.say("	End the object label.");
                inobj = false;
              }
              break;
            case "+":
              self.say(`	Trigger pattern: ${line}`);
              self.initTopic(ast.topics, topic);
              curTrig = {
                trigger: line,
                reply: [],
                condition: [],
                redirect: null,
                previous: isThat
              };
              ast.topics[topic].triggers.push(curTrig);
              break;
            case "-":
              if (curTrig === null) {
                self.warn("Response found before trigger", filename, lineno);
                continue;
              }
              if (curTrig.redirect !== null) {
                self.warn("You can't mix @Redirects with -Replies", filename, lineno);
              }
              self.say(`	Response: ${line}`);
              curTrig.reply.push(line);
              break;
            case "*":
              if (curTrig === null) {
                self.warn("Condition found before trigger", filename, lineno);
                continue;
              }
              if (curTrig.redirect !== null) {
                self.warn("You can't mix @Redirects with *Conditions", filename, lineno);
              }
              self.say(`	Condition: ${line}`);
              curTrig.condition.push(line);
              break;
            case "%":
              continue;
            case "^":
              continue;
            case "@":
              if (curTrig.reply.length > 0 || curTrig.condition.length > 0) {
                self.warn("You can't mix @Redirects with -Replies or *Conditions", filename, lineno);
              }
              self.say(`	Redirect response to: ${line}`);
              curTrig.redirect = utils.strip(line);
              break;
            default:
              self.warn(`Unknown command '${cmd}' (in topic ${topic})`, filename, lineno);
          }
        }
        return ast;
      }
      /**
      	string stringify (data deparsed)
      
      	Translate deparsed data into the source code of a RiveScript document.
      	See the `stringify()` method on the parent RiveScript class; this is its
      	implementation.
      	*/
      stringify(deparsed) {
        var self = this;
        if (deparsed == null) {
          deparsed = self.master.deparse();
        }
        let _writeTriggers = function(triggers, indent) {
          let id = indent ? "	" : "";
          let output = [];
          for (let j = 0, len = triggers.length; j < len; j++) {
            let t = triggers[j];
            output.push(`${id}+ ${t.trigger}`);
            if (t.previous) {
              output.push(`${id}% ${t.previous}`);
            }
            if (t.condition) {
              for (let k = 0, len1 = t.condition.length; k < len1; k++) {
                let c = t.condition[k];
                output.push(`${id}* ${c.replace(/\n/mg, "\\n")}`);
              }
            }
            if (t.redirect) {
              output.push(`${id}@ ${t.redirect}`);
            }
            if (t.reply) {
              for (let l = 0, len2 = t.reply.length; l < len2; l++) {
                let r = t.reply[l];
                if (r) {
                  output.push(`${id}- ${r.replace(/\n/mg, "\\n")}`);
                }
              }
            }
            output.push("");
          }
          return output;
        };
        const source2 = ["! version = 2.0", "! local concat = none", ""];
        const ref = ["global", "var", "sub", "person", "array"];
        for (let j = 0, len = ref.length; j < len; j++) {
          let begin = ref[j];
          if (deparsed.begin[begin] != null && Object.keys(deparsed.begin[begin]).length) {
            for (const key in deparsed.begin[begin]) {
              let value = deparsed.begin[begin][key];
              if (!deparsed.begin[begin].hasOwnProperty(key)) {
                continue;
              }
              if (begin !== "array") {
                source2.push(`! ${begin} ${key} = ${value}`);
              } else {
                let pipes = " ";
                for (let k = 0, len1 = value.length; k < len1; k++) {
                  let test = value[k];
                  if (test.match(/\s+/)) {
                    pipes = "|";
                    break;
                  }
                }
                source2.push(`! ${begin} ${key} = ` + value.join(pipes));
              }
            }
            source2.push("");
          }
        }
        if (deparsed.objects) {
          for (let lang in deparsed.objects) {
            if (deparsed.objects[lang] && deparsed.objects[lang]._objects) {
              for (let func in deparsed.objects[lang]._objects) {
                source2.push("> object " + func + " " + lang);
                source2.push(deparsed.objects[lang]._objects[func].toString().match(/function[^{]+\{\n*([\s\S]*)\}\;?\s*$/m)[1].trim().split("\n").map(function(ln) {
                  return "	" + ln;
                }).join("\n"));
                source2.push("< object\n");
              }
            }
          }
        }
        if (deparsed.begin.triggers && deparsed.begin.triggers.length > 0) {
          source2.push("> begin\n");
          source2.push.apply(source2, _writeTriggers(deparsed.begin.triggers, "indent"));
          source2.push("< begin\n");
        }
        let topics = Object.keys(deparsed.topics).sort(function(a, b) {
          return a - b;
        });
        topics.unshift("random");
        let doneRandom = false;
        for (let l = 0, len2 = topics.length; l < len2; l++) {
          let topic = topics[l];
          if (!deparsed.topics.hasOwnProperty(topic)) {
            continue;
          }
          if (topic === "random" && doneRandom) {
            continue;
          }
          if (topic === "random") {
            doneRandom = 1;
          }
          let tagged = false;
          let tagline = [];
          if (topic !== "random" || (Object.keys(deparsed.inherits[topic]).length > 0 || Object.keys(deparsed.includes[topic]).length > 0)) {
            if (topic !== "random") {
              tagged = true;
            }
            let inherits = [];
            let includes = [];
            for (let i in deparsed.inherits[topic]) {
              if (!deparsed.inherits[topic].hasOwnProperty(i)) {
                continue;
              }
              inherits.push(i);
            }
            for (let i in deparsed.includes[topic]) {
              if (!deparsed.includes[topic].hasOwnProperty(i)) {
                continue;
              }
              includes.push(i);
            }
            if (includes.length > 0) {
              includes.unshift("includes");
              tagline.push.apply(tagline, includes);
              tagged = true;
            }
            if (inherits.length > 0) {
              inherits.unshift("inherits");
              tagline.push.apply(tagline, inherits);
              tagged = true;
            }
          }
          if (tagged) {
            source2.push((`> topic ${topic} ` + tagline.join(" ")).trim() + "\n");
          }
          source2.push.apply(source2, _writeTriggers(deparsed.topics[topic], tagged));
          if (tagged) {
            source2.push("< topic\n");
          }
        }
        return source2.join("\n");
      }
      /**
      	string checkSyntax (char command, string line)
      
      	Check the syntax of a RiveScript command. `command` is the single character
      	command symbol, and `line` is the rest of the line after the command.
      
      	Returns an empty string on success, or a description of the error on error.
      	*/
      checkSyntax(cmd, line) {
        var self = this;
        if (cmd === "!") {
          if (!line.match(/^.+(?:\s+.+|)\s*=\s*.+?$/)) {
            return "Invalid format for !Definition line: must be '! type name = value' OR '! type = value'";
          } else if (line.match(/^array/)) {
            if (line.match(/\=\s?\||\|\s?$/)) {
              return "Piped arrays can't begin or end with a |";
            } else if (line.match(/\|\|/)) {
              return "Piped arrays can't include blank entries";
            }
          }
        } else if (cmd === ">") {
          let parts = line.split(/\s+/);
          if (parts[0] === "begin" && parts.length > 1) {
            return "The 'begin' label takes no additional arguments";
          } else if (parts[0] === "topic") {
            if (!self.master._forceCase && line.match(/[^a-z0-9_\-\s]/)) {
              return "Topics should be lowercased and contain only letters and numbers";
            } else if (line.match(/[^A-Za-z0-9_\-\s]/)) {
              return "Topics should contain only letters and numbers in forceCase mode";
            }
          } else if (parts[0] === "object") {
            if (line.match(/[^A-Za-z0-9_\-\s]/)) {
              return "Objects can only contain numbers and letters";
            }
          }
        } else if (cmd === "+" || cmd === "%" || cmd === "@") {
          let parens = 0, square = 0, curly = 0, angle = 0;
          if (self.utf8) {
            if (line.match(/[A-Z\\.]/)) {
              return "Triggers can't contain uppercase letters, backslashes or dots in UTF-8 mode";
            }
          } else if (line.match(/[^a-z0-9(|)\[\]*_#@{}<>=\/\s]/)) {
            return "Triggers may only contain lowercase letters, numbers, and these symbols: ( | ) [ ] * _ # { } < > = /";
          } else if (line.match(/\(\||\|\)/)) {
            return "Piped alternations can't begin or end with a |";
          } else if (line.match(/\([^\)].+\|\|.+\)/)) {
            return "Piped alternations can't include blank entries";
          } else if (line.match(/\[\||\|\]/)) {
            return "Piped optionals can't begin or end with a |";
          } else if (line.match(/\[[^\]].+\|\|.+\]/)) {
            return "Piped optionals can't include blank entries";
          }
          let chars = line.split("");
          for (let j = 0, len = chars.length; j < len; j++) {
            let char = chars[j];
            switch (char) {
              case "(":
                parens++;
                break;
              case ")":
                parens--;
                break;
              case "[":
                square++;
                break;
              case "]":
                square--;
                break;
              case "{":
                curly++;
                break;
              case "}":
                curly--;
                break;
              case "<":
                angle++;
                break;
              case ">":
                angle--;
                break;
            }
          }
          if (parens !== 0) {
            return "Unmatched parenthesis brackets";
          }
          if (square !== 0) {
            return "Unmatched square brackets";
          }
          if (curly !== 0) {
            return "Unmatched curly brackets";
          }
          if (angle !== 0) {
            return "Unmatched angle brackets";
          }
        } else if (cmd === "*") {
          if (!line.match(/^.+?\s*(?:==|eq|!=|ne|<>|<|<=|>|>=)\s*.+?=>.+?$/)) {
            return "Invalid format for !Condition: should be like '* value symbol value => response'";
          }
        }
        return "";
      }
      /**
      	private void initTopic (object topics, string name)
      
      	Initialize the topic tree for the parsing phase. Sets up the topic under
      	ast.topics with all its relevant keys and sub-keys, etc.
      	*/
      initTopic(topics, name2) {
        var self = this;
        if (topics[name2] === void 0) {
          topics[name2] = {
            includes: {},
            inherits: {},
            triggers: []
          };
        }
      }
    };
    module2.exports = Parser;
  }
});

// node_modules/rivescript/src/inheritance.js
var require_inheritance = __commonJS({
  "node_modules/rivescript/src/inheritance.js"(exports2) {
    "use strict";
    var getTopicTriggers = function(rs, topic, thats, depth, inheritance, inherited) {
      var self = this;
      if (thats == null) {
        thats = false;
      }
      if (depth == null) {
        depth = 0;
      }
      if (inheritance == null) {
        inheritance = 0;
      }
      if (inherited == null) {
        inherited = 0;
      }
      if (depth > rs._depth) {
        rs.warn(`Deep recursion while scanning topic inheritance (gave up in topic ${topic})!`);
        return [];
      }
      rs.say(`Collecting trigger list for topic ${topic} (depth=${depth}; inheritance=${inheritance}; inherited=${inherited})`);
      if (rs._topics[topic] == null) {
        rs.warn(`Inherited or included topic '${topic}' doesn't exist or has no triggers`);
        return [];
      }
      let triggers = [];
      let inThisTopic = [];
      if (!thats) {
        if (rs._topics[topic] != null) {
          for (let i = 0, len = rs._topics[topic].length; i < len; i++) {
            let trigger = rs._topics[topic][i];
            inThisTopic.push([trigger.trigger, trigger]);
          }
        }
      } else {
        if (rs._thats[topic] != null) {
          for (let curTrig in rs._thats[topic]) {
            if (!rs._thats[topic].hasOwnProperty(curTrig)) {
              continue;
            }
            for (let previous in rs._thats[topic][curTrig]) {
              if (!rs._thats[topic][curTrig].hasOwnProperty(previous)) {
                continue;
              }
              let pointer = rs._thats[topic][curTrig][previous];
              inThisTopic.push([pointer.trigger, pointer]);
            }
          }
        }
      }
      if (Object.keys(rs._includes[topic]).length > 0) {
        for (let includes in rs._includes[topic]) {
          if (!rs._includes[topic].hasOwnProperty(includes)) {
            continue;
          }
          rs.say(`Topic ${topic} includes ${includes}`);
          triggers.push.apply(triggers, getTopicTriggers(rs, includes, thats, depth + 1, inheritance + 1, false));
        }
      }
      if (Object.keys(rs._inherits[topic]).length > 0) {
        for (let inherits in rs._inherits[topic]) {
          if (!rs._inherits[topic].hasOwnProperty(inherits)) {
            continue;
          }
          rs.say(`Topic ${topic} inherits ${inherits}`);
          triggers.push.apply(triggers, getTopicTriggers(rs, inherits, thats, depth + 1, inheritance + 1, true));
        }
      }
      if (Object.keys(rs._inherits[topic]).length > 0 || inherited) {
        for (let j = 0, len1 = inThisTopic.length; j < len1; j++) {
          let trigger = inThisTopic[j];
          rs.say(`Prefixing trigger with {inherits=${inheritance}} ${trigger}`);
          triggers.push.apply(triggers, [[`{inherits=${inheritance}}${trigger[0]}`, trigger[1]]]);
        }
      } else {
        triggers.push.apply(triggers, inThisTopic);
      }
      return triggers;
    };
    var getTopicTree = function(rs, topic, depth) {
      var self = this;
      if (depth == null) {
        depth = 0;
      }
      if (depth > rs._depth) {
        rs.warn("Deep recursion while scanning topic tree!");
        return [];
      }
      let topics = [topic];
      for (let includes in rs._topics[topic].includes) {
        if (!rs._topics[topic].includes.hasOwnProperty(includes)) {
          continue;
        }
        topics.push.apply(topics, getTopicTree(rs, includes, depth + 1));
      }
      for (let inherits in rs._topics[topic].inherits) {
        if (!rs._topics[topic].inherits.hasOwnProperty(inherits)) {
          continue;
        }
        topics.push.apply(topics, getTopicTree(rs, inherits, depth + 1));
      }
      return topics;
    };
    exports2.getTopicTriggers = getTopicTriggers;
    exports2.getTopicTree = getTopicTree;
  }
});

// node_modules/rivescript/src/brain.js
var require_brain = __commonJS({
  "node_modules/rivescript/src/brain.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var inherit_utils = require_inheritance();
    var tags = {
      "bot": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let split = data.split("=");
          if (split.length > 1) {
            rive._var[split[0].trim()] = split[1];
            return "";
          } else if (split.length === 1) {
            let val = rive._var[split[0].trim()];
            if (val === void 0)
              val = "undefined";
            return val;
          } else {
            return "undefined";
          }
        }
      },
      "env": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let split = data.split("=");
          if (split.length > 1) {
            rive._global[split[0].trim()] = split[1];
            return "";
          } else if (split.length === 1) {
            let val = rive._global[split[0].trim()];
            if (val === void 0)
              val = "undefined";
            return val;
          } else {
            return "undefined";
          }
        }
      },
      "set": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let split = data.split("=");
          await rive.setUservar(user, split[0].trim(), split[1]);
          return "";
        }
      },
      "get": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let result = await rive.getUservar(user, data.trim());
          return result;
        }
      },
      "add": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let split = data.split("=");
          let name2 = split[0].trim();
          let existingValue = await rive.getUservar(user, name2) || 0;
          if (existingValue === "undefined")
            existingValue = 0;
          let value = parseInt(split[1].trim());
          let existingNumber = parseInt(existingValue);
          if (isNaN(value)) {
            return `[ERR: Math can't 'add' non-numeric value '${value}']`;
          } else if (isNaN(existingNumber)) {
            return `[ERR: Math can't 'add' non-numeric user variable '${name2}']`;
          } else {
            let result = Number(existingNumber + value);
            await rive.setUservar(user, name2, result);
          }
          return "";
        }
      },
      "sub": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let split = data.split("=");
          let name2 = split[0].trim();
          let existingValue = await rive.getUservar(user, name2) || 0;
          let value = parseInt(split[1].trim());
          if (existingValue === "undefined")
            existingValue = 0;
          let existingNumber = parseInt(existingValue);
          if (isNaN(value)) {
            return `[ERR: Math can't 'sub' non-numeric value '${value}']`;
          } else if (isNaN(existingNumber)) {
            return `[ERR: Math can't 'sub' non-numeric user variable '${name2}']`;
          } else {
            let result = Number(existingNumber - value);
            await rive.setUservar(user, name2, result);
          }
          return "";
        }
      },
      "mult": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let split = data.split("=");
          let name2 = split[0].trim();
          let existingValue = await rive.getUservar(user, name2) || 0;
          let value = parseInt(split[1].trim());
          if (existingValue === "undefined")
            existingValue = 0;
          let existingNumber = parseInt(existingValue);
          if (isNaN(value)) {
            return `[ERR: Math can't 'mult' non-numeric value '${value}']`;
          } else if (isNaN(existingNumber)) {
            return `[ERR: Math can't 'mult' non-numeric user variable '${name2}']`;
          } else {
            let result = Number(existingNumber * value);
            await rive.setUservar(user, name2, result);
          }
          return "";
        }
      },
      "div": {
        selfClosing: true,
        handle: async (rive, data, user, scope) => {
          let split = data.split("=");
          let name2 = split[0].trim();
          let existingValue = await rive.getUservar(user, name2) || 0;
          let value = parseInt(split[1].trim());
          if (existingValue === "undefined")
            existingValue = 0;
          let existingNumber = parseInt(existingValue);
          if (isNaN(value)) {
            return `[ERR: Math can't 'div' non-numeric value '${value}']`;
          } else if (isNaN(existingNumber)) {
            return `[ERR: Math can't 'div' non-numeric user variable '${name2}']`;
          } else if (value === 0) {
            return `[ERR: Can't Divide By Zero]`;
          } else {
            let result = Number(existingNumber / value);
            await rive.setUservar(user, name2, result);
          }
          return "";
        }
      },
      "call": {
        selfClosing: false,
        handle: async (rive, data, user, scope) => {
          let parts = utils.trim(data).split(" ");
          let output = rive.errors.objectNotFound;
          let obj = parts[0];
          let args = [];
          if (parts.length > 1) {
            args = utils.parseCallArgs(parts.slice(1).join(" "));
          }
          if (obj in rive._objlangs) {
            let lang = rive._objlangs[obj];
            if (lang in rive._handlers) {
              try {
                output = await rive._handlers[lang].call(rive, obj, args, scope);
              } catch (error) {
                if (error != void 0) {
                  rive.brain.warn(error);
                }
                output = `[ERR: Error raised by object macro: ${error.message}]`;
              }
            } else {
              output = "[ERR: No Object Handler]";
            }
          }
          return output;
        }
      }
    };
    var Brain = class {
      constructor(master2) {
        var self = this;
        self.master = master2;
        self.strict = master2._strict;
        self.utf8 = master2._utf8;
        self._currentUser = null;
      }
      // Proxy functions
      say(message) {
        return this.master.say(message);
      }
      warn(message, filename, lineno) {
        return this.master.warn(message, filename, lineno);
      }
      /**
      	async reply (string user, string msg[, scope])
      
      	Fetch a reply for the user. This returns a Promise that may be awaited on.
      	*/
      async reply(user, msg, scope) {
        var self = this;
        self.say(`Asked to reply to [${user}] ${msg}`);
        self._currentUser = user;
        msg = self.formatMessage(msg);
        let reply = "";
        await self.master._session.set(user, {
          __initialmatch__: null
        });
        if (self.master._topics.__begin__) {
          let begin = await self._getReply(user, "request", "begin", 0, scope);
          if (begin.indexOf("{ok}") > -1) {
            reply = await self._getReply(user, msg, "normal", 0, scope);
            begin = begin.replace(/\{ok\}/g, reply);
          }
          reply = await self.processTags(user, msg, begin, [], [], 0, scope);
        } else {
          reply = await self._getReply(user, msg, "normal", 0, scope);
        }
        let history = await self.master._session.get(user, "__history__");
        if (history == "undefined") {
          history = newHistory();
        }
        try {
          history.input.pop();
          history.input.unshift(msg);
          history.reply.pop();
          history.reply.unshift(reply);
        } catch (e2) {
          history = newHistory();
        }
        await self.master._session.set(user, {
          __history__: history
        });
        self._currentUser = null;
        return reply;
      }
      /**
      	async _getReply (string user, string msg, string context, int step, scope)
      
      	The internal reply method. DO NOT CALL THIS DIRECTLY.
      
      	* user, msg and scope are the same as reply()
      	* context = "normal" or "begin"
      	* step = the recursion depth
      	* scope = the call scope for object macros
      	*/
      async _getReply(user, msg, context, step, scope) {
        var self = this;
        if (!self.master._sorted.topics) {
          self.warn("You forgot to call sortReplies()!");
          return "ERR: Replies Not Sorted";
        }
        let topic = await self.master.getUservar(user, "topic");
        if (topic === null || topic === "undefined") {
          topic = "random";
        }
        let stars = [];
        let thatstars = [];
        let reply = "";
        if (!self.master._topics[topic]) {
          self.warn(`User ${user} was in an empty topic named '${topic}'`);
          topic = "random";
          await self.master.setUservar(user, "topic", topic);
        }
        if (step > self.master._depth) {
          return self.master.errors.deepRecursion;
        }
        if (context === "begin") {
          topic = "__begin__";
        }
        let history = await self.master._session.get(user, "__history__");
        if (history == "undefined") {
          history = newHistory();
          await self.master._session.set(user, {
            __history__: history
          });
        }
        if (!self.master._topics[topic]) {
          return "ERR: No default topic 'random' was found!";
        }
        let matched = null;
        let matchedTrigger = null;
        let foundMatch = false;
        if (step === 0) {
          let allTopics = [topic];
          if (self.master._topics[topic].includes || self.master._topics[topic].inherits) {
            allTopics = inherit_utils.getTopicTree(self.master, topic);
          }
          for (let j = 0, len = allTopics.length; j < len; j++) {
            let top = allTopics[j];
            self.say(`Checking topic ${top} for any %Previous's`);
            if (self.master._sorted.thats[top].length) {
              self.say("There's a %Previous in this topic!");
              let lastReply = history.reply ? history.reply[0] : "undefined";
              lastReply = self.formatMessage(lastReply, true);
              self.say(`Last reply: ${lastReply}`);
              for (let k = 0, len1 = self.master._sorted.thats[top].length; k < len1; k++) {
                let trig = self.master._sorted.thats[top][k];
                let pattern = trig[1].previous;
                let botside = await self.triggerRegexp(user, pattern);
                self.say(`Try to match lastReply (${lastReply}) to ${botside}`);
                let match = lastReply.match(new RegExp(`^${botside}$`), "i");
                if (match) {
                  self.say("Bot side matched!");
                  thatstars = match;
                  thatstars.shift();
                  let userSide = trig[1];
                  let regexp = await self.triggerRegexp(user, userSide.trigger);
                  self.say(`Try to match "${msg}" against ${userSide.trigger} (${regexp})`);
                  let isAtomic = utils.isAtomic(userSide.trigger);
                  let isMatch = false;
                  if (isAtomic) {
                    if (msg === regexp) {
                      isMatch = true;
                    }
                  } else {
                    let match2 = msg.match(new RegExp(`^${regexp}$`));
                    if (match2) {
                      isMatch = true;
                      stars = match2;
                      if (stars.length >= 1) {
                        stars.shift();
                      }
                    }
                  }
                  if (isMatch) {
                    matched = userSide;
                    foundMatch = true;
                    matchedTrigger = userSide.trigger;
                    break;
                  }
                }
              }
            } else {
              self.say("No %Previous in this topic!");
            }
          }
        }
        if (!foundMatch) {
          self.say("Searching their topic for a match...");
          for (let l = 0, len = self.master._sorted.topics[topic].length; l < len; l++) {
            let trig = self.master._sorted.topics[topic][l];
            let pattern = trig[0];
            let regexp = await self.triggerRegexp(user, pattern);
            self.say(`Try to match "${msg}" against ${pattern} (${regexp})`);
            let isAtomic = utils.isAtomic(pattern);
            let isMatch = false;
            if (isAtomic) {
              if (msg === regexp) {
                isMatch = true;
              }
            } else {
              let match = msg.match(new RegExp(`^${regexp}$`, "i"));
              if (match) {
                isMatch = true;
                stars = [];
                if (match.length > 1) {
                  for (let i = 1, len2 = match.length; i < len2; i++) {
                    stars.push(match[i]);
                  }
                }
              }
            }
            if (isMatch) {
              self.say("Found a match!");
              matched = trig[1];
              foundMatch = true;
              matchedTrigger = pattern;
              break;
            }
          }
        }
        await self.master._session.set(user, { __lastmatch__: matchedTrigger });
        let lastTriggers = [];
        if (step === 0) {
          await self.master._session.set(user, {
            // Store initial matched trigger. Like __lastmatch__, this can be undefined.
            __initialmatch__: matchedTrigger,
            // Also initialize __last_triggers__ which will keep all matched triggers
            __last_triggers__: lastTriggers
          });
        }
        if (matched) {
          lastTriggers.push(matched);
          await self.master._session.set(user, { __last_triggers__: lastTriggers });
          for (let n = 0; n < 1; n++) {
            if (matched.redirect != null) {
              self.say(`Redirecting us to ${matched.redirect}`);
              let redirect = await self.processTags(user, msg, matched.redirect, stars, thatstars, step, scope);
              self.say(`Pretend user said: ${redirect}`);
              reply = await self._getReply(user, redirect, context, step + 1, scope);
              break;
            }
            for (let o = 0, len4 = matched.condition.length; o < len4; o++) {
              let row = matched.condition[o];
              let halves = row.split(/\s*=>\s*/);
              if (halves && halves.length === 2) {
                let condition = halves[0].match(/^(.+?)\s+(==|eq|!=|ne|<>|<|<=|>|>=)\s+(.*?)$/);
                if (condition) {
                  let left = utils.strip(condition[1]);
                  let eq = condition[2];
                  let right = utils.strip(condition[3]);
                  let potreply = halves[1].trim();
                  left = await self.processTags(user, msg, left, stars, thatstars, step, scope);
                  right = await self.processTags(user, msg, right, stars, thatstars, step, scope);
                  if (left.length === 0) {
                    left = "undefined";
                  }
                  if (right.length === 0) {
                    right = "undefined";
                  }
                  self.say(`Check if ${left} ${eq} ${right}`);
                  let passed = false;
                  if (eq === "eq" || eq === "==") {
                    if (left === right) {
                      passed = true;
                    }
                  } else if (eq === "ne" || eq === "!=" || eq === "<>") {
                    if (left !== right) {
                      passed = true;
                    }
                  } else {
                    try {
                      left = parseInt(left);
                      right = parseInt(right);
                      if (eq === "<" && left < right) {
                        passed = true;
                      } else if (eq === "<=" && left <= right) {
                        passed = true;
                      } else if (eq === ">" && left > right) {
                        passed = true;
                      } else if (eq === ">=" && left >= right) {
                        passed = true;
                      }
                    } catch (error) {
                      e = error;
                      self.warn("Failed to evaluate numeric condition!");
                    }
                  }
                  if (passed) {
                    reply = potreply;
                    break;
                  }
                }
              }
            }
            if (reply !== null && reply.length > 0) {
              break;
            }
            let bucket = [];
            for (let q = 0, len5 = matched.reply.length; q < len5; q++) {
              let rep = matched.reply[q];
              let weight = 1;
              let match = rep.match(/\{weight=(\d+?)\}/i);
              if (match) {
                weight = match[1];
                if (weight <= 0) {
                  self.warn("Can't have a weight <= 0!");
                  weight = 1;
                }
              }
              for (let i = 0; i < weight; i++) {
                bucket.push(rep);
              }
            }
            let choice = parseInt(Math.random() * bucket.length);
            reply = bucket[choice];
            break;
          }
        }
        if (!foundMatch) {
          reply = self.master.errors.replyNotMatched;
        } else if (reply === void 0 || reply.length === 0) {
          reply = self.master.errors.replyNotFound;
        }
        self.say(`Reply: ${reply}`);
        if (context === "begin") {
          let match = reply.match(/\{topic=(.+?)\}/i);
          let giveup = 0;
          while (match) {
            giveup++;
            if (giveup >= 50) {
              self.warn("Infinite loop looking for topic tag!");
              break;
            }
            let name2 = match[1];
            await self.master.setUservar(user, "topic", name2);
            reply = reply.replace(new RegExp("{topic=" + utils.quotemeta(name2) + "}", "ig"), "");
            match = reply.match(/\{topic=(.+?)\}/i);
          }
          match = reply.match(/<set (.+?)=(.+?)>/i);
          giveup = 0;
          while (match) {
            giveup++;
            if (giveup >= 50) {
              self.warn("Infinite loop looking for set tag!");
              break;
            }
            let name2 = match[1];
            let value = match[2];
            await self.master.setUservar(user, name2, value);
            reply = reply.replace(new RegExp("<set " + utils.quotemeta(name2) + "=" + utils.quotemeta(value) + ">", "ig"), "");
            match = reply.match(/<set (.+?)=(.+?)>/i);
          }
        } else {
          reply = self.processTags(user, msg, reply, stars, thatstars, step, scope);
        }
        return reply;
      }
      /**
      	string formatMessage (string msg)
      
      	Format a user's message for safe processing.
      	*/
      formatMessage(msg, botreply) {
        var self = this;
        msg = "" + msg;
        if (self.master._caseSensitive !== true) {
          msg = msg.toLowerCase();
        }
        msg = self.substitute(msg, "sub");
        if (self.utf8) {
          msg = msg.replace(/[\\<>]+/, "");
          if (self.master.unicodePunctuation != null) {
            msg = msg.replace(self.master.unicodePunctuation, "");
          }
          if (botreply != null) {
            msg = msg.replace(/[.?,!;:@#$%^&*()]/, "");
          }
        } else {
          msg = utils.stripNasties(msg, self.utf8);
        }
        msg = msg.trim();
        msg = msg.replace(/\s+/g, " ");
        return msg;
      }
      /**
      	async triggerRegexp (string user, string trigger)
      
      	Prepares a trigger for the regular expression engine.
      	*/
      async triggerRegexp(user, regexp) {
        var self = this;
        regexp = regexp.replace(/^\*$/, "<zerowidthstar>");
        regexp = regexp.replace(/\*/g, "(.+?)");
        regexp = regexp.replace(/#/g, "(\\d+?)");
        regexp = regexp.replace(/_/g, "(\\w+?)");
        regexp = regexp.replace(/\s*\{weight=\d+\}\s*/g, "");
        regexp = regexp.replace(/<zerowidthstar>/g, "(.*?)");
        regexp = regexp.replace(/\|{2,}/, "|");
        regexp = regexp.replace(/(\(|\[)\|/g, "$1");
        regexp = regexp.replace(/\|(\)|\])/g, "$1");
        if (self.utf8) {
          regexp = regexp.replace(/\\@/, "\\u0040");
        }
        let match = regexp.match(/\[(.+?)\]/);
        let giveup = 0;
        while (match) {
          if (giveup++ > 50) {
            self.warn("Infinite loop when trying to process optionals in a trigger!");
            return "";
          }
          let parts = match[1].split("|");
          let opts = [];
          for (let j = 0, len = parts.length; j < len; j++) {
            let p = parts[j];
            opts.push(`(?:\\s|\\b)+${p}(?:\\s|\\b)+`);
          }
          let pipes = opts.join("|");
          pipes = pipes.replace(new RegExp(utils.quotemeta("(.+?)"), "g"), "(?:.+?)");
          pipes = pipes.replace(new RegExp(utils.quotemeta("(\\d+?)"), "g"), "(?:\\d+?)");
          pipes = pipes.replace(new RegExp(utils.quotemeta("(\\w+?)"), "g"), "(?:\\w+?)");
          pipes = pipes.replace(/\[/g, "__lb__").replace(/\]/g, "__rb__");
          regexp = regexp.replace(new RegExp("\\s*\\[" + utils.quotemeta(match[1]) + "\\]\\s*"), `(?:${pipes}|(?:\\b|\\s)+)`);
          match = regexp.match(/\[(.+?)\]/);
        }
        regexp = regexp.replace(/__lb__/g, "[").replace(/__rb__/g, "]");
        regexp = regexp.replace(/\\w/g, "[^\\s\\d]");
        giveup = 0;
        while (regexp.indexOf("@") > -1) {
          if (giveup++ > 50) {
            break;
          }
          let match2 = regexp.match(/\@(.+?)\b/);
          if (match2) {
            let name2 = match2[1];
            let rep = "";
            if (self.master._array[name2]) {
              rep = "(?:" + self.master._array[name2].join("|") + ")";
            }
            regexp = regexp.replace(new RegExp("@" + utils.quotemeta(name2) + "\\b"), rep);
          }
        }
        giveup = 0;
        while (regexp.indexOf("<bot") > -1) {
          if (giveup++ > 50) {
            break;
          }
          let match2 = regexp.match(/<bot (.+?)>/i);
          if (match2) {
            let name2 = match2[1];
            let rep = "";
            if (self.master._var[name2]) {
              rep = utils.stripNasties(self.master._var[name2], self.utf8);
            }
            regexp = regexp.replace(new RegExp("<bot " + utils.quotemeta(name2) + ">"), rep.toLowerCase());
          }
        }
        giveup = 0;
        while (regexp.indexOf("<get") > -1) {
          if (giveup++ > 50) {
            break;
          }
          let match2 = regexp.match(/<get (.+?)>/i);
          if (match2) {
            let name2 = match2[1];
            let rep = await self.master.getUservar(user, name2);
            regexp = regexp.replace(new RegExp("<get " + utils.quotemeta(name2) + ">", "ig"), rep.toLowerCase());
          }
        }
        giveup = 0;
        regexp = regexp.replace(/<input>/i, "<input1>");
        regexp = regexp.replace(/<reply>/i, "<reply1>");
        let history = await self.master._session.get(user, "__history__");
        if (history == "undefined") {
          history = newHistory();
        }
        while (regexp.indexOf("<input") > -1 || regexp.indexOf("<reply") > -1) {
          if (giveup++ > 50) {
            break;
          }
          let ref = ["input", "reply"];
          for (let k = 0, len1 = ref.length; k < len1; k++) {
            let type = ref[k];
            for (let i = 1; i <= 9; i++) {
              if (regexp.indexOf(`<${type}${i}>`) > -1) {
                let value = self.formatMessage(history[type][i - 1], type === "reply");
                regexp = regexp.replace(new RegExp(`<${type}${i}>`, "g"), value);
              }
            }
          }
        }
        if (self.utf8 && regexp.indexOf("\\u") > -1) {
          regexp = regexp.replace(/\\u([A-Fa-f0-9]{4})/, function(match2, grp) {
            return String.fromCharCode(parseInt(grp, 16));
          });
        }
        regexp = regexp.replace(/\|{2,}/mg, "|");
        return regexp;
      }
      async handleTag(rive, user, content2, scope, depth) {
        let tag = "";
        let reminder = "";
        for (let i = 0; i < content2.length; i++) {
          if (tags[tag]) {
            reminder = content2.substring(i + 1);
            break;
          } else if (content2[i] === " ") {
            reminder = content2.substring(i + 1);
            break;
          } else if (content2[i] === ">") {
            reminder = content2.substring(i + 1);
            return { response: "<" + tag + ">", reminder };
          }
          tag += content2[i];
        }
        const selfClosing = tags[tag] ? tags[tag].selfClosing : true;
        const endTag = selfClosing ? ">" : "</" + tag + ">";
        const result = await this.parseComplexTags(rive, user, reminder, scope, depth, endTag);
        reminder = result.reminder;
        const response = tags[tag] && tags[tag].handle ? await tags[tag].handle(rive, result.response, user, scope) : "<" + tag + " " + result.response + ">";
        return { response, reminder };
      }
      async parseComplexTags(rive, user, content2, scope, depth, endTag = "") {
        if (depth > 50)
          return { response: content2, reminder: "" };
        let response = "";
        let reminder = content2;
        let nextTag = reminder.indexOf("<");
        let nextEnd = endTag ? reminder.indexOf(endTag) : reminder.length;
        while (reminder.length > 0 && nextTag > -1 && nextTag < nextEnd) {
          response += reminder.substring(0, nextTag);
          reminder = reminder.substring(nextTag + 1);
          let result = await this.handleTag(rive, user, reminder, scope, depth + 1);
          response += result.response;
          reminder = result.reminder;
          nextTag = reminder.indexOf("<");
          nextEnd = endTag ? reminder.indexOf(endTag) : reminder.length;
        }
        response += reminder.substring(0, nextEnd);
        reminder = reminder.substring(nextEnd + endTag.length);
        return { response, reminder };
      }
      /**
      	string processTags (string user, string msg, string reply, string[] stars,
      						string[] botstars, int step, scope)
      
      	Process tags in a reply element.
      	*/
      async processTags(user, msg, reply, st, bst, step, scope) {
        var self = this;
        let stars = [""];
        stars.push.apply(stars, st);
        let botstars = [""];
        botstars.push.apply(botstars, bst);
        if (stars.length === 1) {
          stars.push("undefined");
        }
        if (botstars.length === 1) {
          botstars.push("undefined");
        }
        let match = reply.match(/\(@([A-Za-z0-9_]+)\)/i);
        let giveup = 0;
        while (match) {
          if (giveup++ > self.master._depth) {
            self.warn("Infinite loop looking for arrays in reply!");
            break;
          }
          let name2 = match[1];
          let result;
          if (self.master._array[name2]) {
            result = "{random}" + self.master._array[name2].join("|") + "{/random}";
          } else {
            result = `\0@${name2}\0`;
          }
          reply = reply.replace(new RegExp("\\(@" + utils.quotemeta(name2) + "\\)", "ig"), result);
          match = reply.match(/\(@([A-Za-z0-9_]+)\)/i);
        }
        reply = reply.replace(/\x00@([A-Za-z0-9_]+)\x00/g, "(@$1)");
        reply = reply.replace(/<person>/ig, "{person}<star>{/person}");
        reply = reply.replace(/<@>/ig, "{@<star>}");
        reply = reply.replace(/<formal>/ig, "{formal}<star>{/formal}");
        reply = reply.replace(/<sentence>/ig, "{sentence}<star>{/sentence}");
        reply = reply.replace(/<uppercase>/ig, "{uppercase}<star>{/uppercase}");
        reply = reply.replace(/<lowercase>/ig, "{lowercase}<star>{/lowercase}");
        reply = reply.replace(/\{weight=\d+\}/ig, "");
        reply = reply.replace(/<star>/ig, stars[1]);
        reply = reply.replace(/<botstar>/ig, botstars[1]);
        for (let i = 1, len = stars.length; i <= len; i++) {
          reply = reply.replace(new RegExp(`<star${i}>`, "ig"), stars[i]);
        }
        for (let i = 1, len = botstars.length; i <= len; i++) {
          reply = reply.replace(new RegExp(`<botstar${i}>`, "ig"), botstars[i]);
        }
        let history = await self.master._session.get(user, "__history__");
        if (history == "undefined") {
          history = newHistory();
        }
        reply = reply.replace(/<input>/ig, history.input ? history.input[0] : "undefined");
        reply = reply.replace(/<reply>/ig, history.reply ? history.reply[0] : "undefined");
        for (let i = 1; i <= 9; i++) {
          if (reply.indexOf(`<input${i}>`) > -1) {
            reply = reply.replace(new RegExp(`<input${i}>`, "ig"), history.input[i - 1]);
          }
          if (reply.indexOf(`<reply${i}>`) > -1) {
            reply = reply.replace(new RegExp(`<reply${i}>`, "ig"), history.reply[i - 1]);
          }
        }
        reply = reply.replace(/<id>/ig, user);
        reply = reply.replace(/\\s/ig, " ");
        reply = reply.replace(/\\n/ig, "\n");
        reply = reply.replace(/\\#/ig, "#");
        match = reply.match(/\{random\}(.+?)\{\/random\}/i);
        giveup = 0;
        while (match) {
          if (giveup++ > self.master._depth) {
            self.warn("Infinite loop looking for random tag!");
            break;
          }
          let random = [];
          let text = match[1];
          if (text.indexOf("|") > -1) {
            random = text.split("|");
          } else {
            random = text.split(" ");
          }
          let output = random[parseInt(Math.random() * random.length)];
          reply = reply.replace(new RegExp("\\{random\\}" + utils.quotemeta(text) + "\\{\\/random\\}", "ig"), output);
          match = reply.match(/\{random\}(.+?)\{\/random\}/i);
        }
        let formats = ["person", "formal", "sentence", "uppercase", "lowercase"];
        for (let m = 0, len = formats.length; m < len; m++) {
          let type = formats[m];
          match = reply.match(new RegExp(`{${type}}(.+?){/${type}}`, "i"));
          giveup = 0;
          while (match) {
            giveup++;
            if (giveup >= 50) {
              self.warn(`Infinite loop looking for ${type} tag!`);
              break;
            }
            let content2 = match[1];
            let replace;
            if (type === "person") {
              replace = self.substitute(content2, "person");
            } else {
              replace = utils.stringFormat(type, content2);
            }
            reply = reply.replace(new RegExp(`{${type}}` + utils.quotemeta(content2) + `{/${type}}`, "ig"), replace);
            match = reply.match(new RegExp(`{${type}}(.+?){/${type}}`, "i"));
          }
        }
        reply = (await self.parseComplexTags(self.master, user, reply, scope, 0)).response;
        match = reply.match(/\{topic=(.+?)\}/i);
        giveup = 0;
        while (match) {
          giveup++;
          if (giveup >= 50) {
            self.warn("Infinite loop looking for topic tag!");
            break;
          }
          let name2 = match[1];
          await self.master.setUservar(user, "topic", name2);
          reply = reply.replace(new RegExp("{topic=" + utils.quotemeta(name2) + "}", "ig"), "");
          match = reply.match(/\{topic=(.+?)\}/i);
        }
        match = reply.match(/\{@([^\}]*?)\}/);
        giveup = 0;
        while (match) {
          giveup++;
          if (giveup >= 50) {
            self.warn("Infinite loop looking for redirect tag!");
            break;
          }
          let target = utils.strip(match[1]);
          self.say(`Inline redirection to: ${target}`);
          let subreply = await self._getReply(user, target, "normal", step + 1, scope);
          reply = reply.replace(new RegExp("\\{@" + utils.quotemeta(match[1]) + "\\}", "i"), subreply);
          match = reply.match(/\{@([^\}]*?)\}/);
        }
        return reply;
      }
      /**
      	string substitute (string msg, string type)
      
      	Run substitutions against a message. `type` is either "sub" or "person" for
      	the type of substitution to run.
      	*/
      substitute(msg, type) {
        var self = this;
        if (!self.master._sorted[type]) {
          self.master.warn("You forgot to call sortReplies()!");
          return "";
        }
        let subs = type === "sub" ? self.master._sub : self.master._person;
        let maxwords = type === "sub" ? self.master._submax : self.master._personmax;
        let result = "";
        var pattern;
        if (self.master.unicodePunctuation != null) {
          pattern = msg.replace(self.master.unicodePunctuation, "");
        } else {
          pattern = msg.replace(/[.,!?;:]/g, "");
        }
        let tries = 0;
        let giveup = 0;
        let subgiveup = 0;
        while (pattern.indexOf(" ") > -1) {
          giveup++;
          if (giveup >= 1e3) {
            self.warn("Too many loops when handling substitutions!");
            break;
          }
          let li = utils.nIndexOf(pattern, " ", maxwords);
          let subpattern = pattern.substring(0, li);
          result = subs[subpattern];
          if (result !== void 0) {
            msg = msg.replace(subpattern, result);
          } else {
            while (subpattern.indexOf(" ") > -1) {
              subgiveup++;
              if (subgiveup >= 1e3) {
                self.warn("Too many loops when handling substitutions!");
                break;
              }
              li = subpattern.lastIndexOf(" ");
              subpattern = subpattern.substring(0, li);
              result = subs[subpattern];
              if (result !== void 0) {
                msg = msg.replace(subpattern, result);
                break;
              }
              tries++;
            }
          }
          let fi = pattern.indexOf(" ");
          pattern = pattern.substring(fi + 1);
          tries++;
        }
        result = subs[pattern];
        if (result !== void 0) {
          msg = msg.replace(pattern, result);
        }
        return msg;
      }
    };
    function newHistory() {
      return {
        input: ["undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined"],
        reply: ["undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined"]
      };
    }
    module2.exports = Brain;
  }
});

// node_modules/rivescript/src/sorting.js
var require_sorting = __commonJS({
  "node_modules/rivescript/src/sorting.js"(exports2) {
    "use strict";
    var utils = require_utils();
    exports2.sortTriggerSet = function(triggers, exclude_previous, say) {
      var self = this;
      var match;
      if (say == null) {
        say = function(what) {
        };
      }
      if (exclude_previous == null) {
        exclude_previous = true;
      }
      let prior = {
        "0": []
      };
      for (let i = 0, len = triggers.length; i < len; i++) {
        let trig = triggers[i];
        if (exclude_previous && trig[1].previous != null) {
          continue;
        }
        match = trig[0].match(/\{weight=(\d+)\}/i);
        let weight = 0;
        if (match && match[1]) {
          weight = match[1];
        }
        if (prior[weight] == null) {
          prior[weight] = [];
        }
        prior[weight].push(trig);
      }
      let running = [];
      let prior_sort = Object.keys(prior).sort(function(a, b) {
        return b - a;
      });
      for (let j = 0, len1 = prior_sort.length; j < len1; j++) {
        let p = prior_sort[j];
        say(`Sorting triggers with priority ${p}`);
        let inherits = -1;
        let highest_inherits = -1;
        let track = {};
        track[inherits] = initSortTrack();
        for (let k = 0, len2 = prior[p].length; k < len2; k++) {
          let trig = prior[p][k];
          let pattern = trig[0];
          say(`Looking at trigger: ${pattern}`);
          match = pattern.match(/\{inherits=(\d+)\}/i);
          if (match) {
            inherits = parseInt(match[1]);
            if (inherits > highest_inherits) {
              highest_inherits = inherits;
            }
            say(`Trigger belongs to a topic that inherits other topics. Level=${inherits}`);
            pattern = pattern.replace(/\{inherits=\d+\}/ig, "");
            trig[0] = pattern;
          } else {
            inherits = -1;
          }
          if (track[inherits] == null) {
            track[inherits] = initSortTrack();
          }
          if (pattern.indexOf("_") > -1) {
            let cnt = utils.word_count(pattern);
            say(`Has a _ wildcard with ${cnt} words.`);
            if (cnt > 0) {
              if (track[inherits].alpha[cnt] == null) {
                track[inherits].alpha[cnt] = [];
              }
              track[inherits].alpha[cnt].push(trig);
            } else {
              track[inherits].under.push(trig);
            }
          } else if (pattern.indexOf("#") > -1) {
            let cnt = utils.word_count(pattern);
            say(`Has a # wildcard with ${cnt} words.`);
            if (cnt > 0) {
              if (track[inherits].number[cnt] == null) {
                track[inherits].number[cnt] = [];
              }
              track[inherits].number[cnt].push(trig);
            } else {
              track[inherits].pound.push(trig);
            }
          } else if (pattern.indexOf("*") > -1) {
            let cnt = utils.word_count(pattern);
            say(`Has a * wildcard with ${cnt} words.`);
            if (cnt > 0) {
              if (track[inherits].wild[cnt] == null) {
                track[inherits].wild[cnt] = [];
              }
              track[inherits].wild[cnt].push(trig);
            } else {
              track[inherits].star.push(trig);
            }
          } else if (pattern.indexOf("[") > -1) {
            let cnt = utils.word_count(pattern);
            say(`Has optionals with ${cnt} words.`);
            if (track[inherits].option[cnt] == null) {
              track[inherits].option[cnt] = [];
            }
            track[inherits].option[cnt].push(trig);
          } else {
            let cnt = utils.word_count(pattern);
            say(`Totally atomic trigger with ${cnt} words.`);
            if (track[inherits].atomic[cnt] == null) {
              track[inherits].atomic[cnt] = [];
            }
            track[inherits].atomic[cnt].push(trig);
          }
        }
        track[highest_inherits + 1] = track["-1"];
        delete track["-1"];
        let track_sorted = Object.keys(track).sort(function(a, b) {
          return a - b;
        });
        for (let l = 0, len3 = track_sorted.length; l < len3; l++) {
          let ip = track_sorted[l];
          say(`ip=${ip}`);
          const groups = ["atomic", "option", "alpha", "number", "wild"];
          for (let m = 0, len4 = groups.length; m < len4; m++) {
            let kind = groups[m];
            let kind_sorted = Object.keys(track[ip][kind]).sort(function(a, b) {
              return b - a;
            });
            for (let n = 0, len5 = kind_sorted.length; n < len5; n++) {
              let wordcnt = kind_sorted[n];
              let sorted_by_length = track[ip][kind][wordcnt].sort(function(a, b) {
                return b.length - a.length;
              });
              running.push.apply(running, sorted_by_length);
            }
          }
          let under_sorted = track[ip].under.sort(function(a, b) {
            return b.length - a.length;
          });
          let pound_sorted = track[ip].pound.sort(function(a, b) {
            return b.length - a.length;
          });
          let star_sorted = track[ip].star.sort(function(a, b) {
            return b.length - a.length;
          });
          running.push.apply(running, under_sorted);
          running.push.apply(running, pound_sorted);
          running.push.apply(running, star_sorted);
        }
      }
      return running;
    };
    exports2.sortList = function(items) {
      var self = this;
      let track = {};
      for (let i = 0, len = items.length; i < len; i++) {
        let item = items[i];
        let cnt = utils.word_count(item, true);
        if (track[cnt] == null) {
          track[cnt] = [];
        }
        track[cnt].push(item);
      }
      let output = [];
      let sorted = Object.keys(track).sort(function(a, b) {
        return b - a;
      });
      for (let j = 0, len1 = sorted.length; j < len1; j++) {
        let count = sorted[j];
        let bylen = track[count].sort(function(a, b) {
          return b.length - a.length;
        });
        output.push.apply(output, bylen);
      }
      return output;
    };
    var initSortTrack = function() {
      return {
        atomic: {},
        option: {},
        alpha: {},
        number: {},
        wild: {},
        pound: [],
        under: [],
        star: []
      };
    };
  }
});

// node_modules/rivescript/src/sessions.js
var require_sessions = __commonJS({
  "node_modules/rivescript/src/sessions.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var SessionManager = class {
      /**
      	void set(string username, object data)
      
      	Set user variables for the user `username`. The `args` should be an object
      	of key/value pairs. The values are usually strings, but they can be other
      	types as well (e.g. arrays or other objects) for some internal data
      	structures such as input/reply history.
      
      	A value of `null` for a variable means it should be deleted from the
      	user's session store.
      	*/
      async set(username, data) {
        throw "Not Implemented";
      }
      /**
      	async get(string username, string key) -> string
      
      	Retrieve a stored variable for a user.
      
      	If the user doesn't exist, this should resolve `null`. If the user *does*
      	exist, but the key does not, this function should resolve the
      	string value `"undefined"`.
      	*/
      async get(username, key) {
        throw "Not Implemented";
      }
      /**
      	async getAny(string username) -> object
      
      	Retrieve all stored user variables for the user `username`.
      
      	This should resolve an object of the key/value pairs you have stored for
      	the user. If the user doesn't exist, resolve `null`.
      	*/
      async getAny(username) {
        throw "Not Implemented";
      }
      /**
      	async getAll() -> object
      
      	Retrieve all variables about all users.
      
      	This should return an object that maps usernames to an object of their
      	variables. For example:
      
      	```json
      	{ "user1": {
      	    "topic": "random",
              "name": "Alice"
      	  },
      	  "user2": {
      	    "topic": "random",
      	    "name": "Bob"
      	  }
      	}
      	```
      	*/
      async getAll() {
        throw "Not Implemented";
      }
      /**
      	async reset(string username)
      
      	Reset all variables stored about a particular user.
      	*/
      async reset(username) {
        throw "Not Implemented";
      }
      /**
      	async resetAll()
      
      	Reset all data about all users.
      	*/
      async resetAll() {
        throw "Not Implemented";
      }
      /**
      	async freeze(string username)
      
      	Make a snapshot of the user's variables so that they can be restored
      	later via `thaw()`. This is the implementation for
      	`RiveScript.freezeUservars()`
      	*/
      async freeze(username) {
        throw "Not Implemented";
      }
      /**
      	async thaw(string username, string action)
      
      	Restore the frozen snapshot of variables for a user.
      
      	This should replace _all_ of a user's variables with the frozen copy
      	that was snapshotted with `freeze()`. If there are no frozen variables,
      	this function should be a no-op (maybe print a warning?)
      
      	Valid options for `action` reflect the usage of `rs.thawUservars()`:
      
      	* `thaw`: Restore the variables and delete the frozen copy (default)
      	* `discard`: Do not restore the variables, but delete the frozen copy
      	* `keep`: Restore the variables and keep the frozen copy
      	*/
      async thaw(username, action) {
        throw "Not Implemented";
      }
      /**
      	object defaultSession()
      
      	You do not need to override this method. This returns the default session
      	variables for a new user, e.g. with the variable `topic="random"` as per
      	the RiveScript spec.
      	*/
      defaultSession() {
        return {
          "topic": "random"
        };
      }
    };
    var MemorySessionManager = class extends SessionManager {
      constructor() {
        super();
        var self = this;
        self._users = {};
        self._frozen = {};
      }
      // init makes sure a user exists in the session store.
      init(username) {
        var self = this;
        if (self._users[username] === void 0) {
          self._users[username] = self.defaultSession();
        }
      }
      async set(username, data) {
        var self = this;
        return new Promise((resolve, reject) => {
          self.init(username);
          for (var key in data) {
            if (data.hasOwnProperty(key)) {
              self._users[username][key] = data[key];
            }
          }
          resolve();
        });
      }
      async get(username, key) {
        var self = this;
        return new Promise((resolve, reject) => {
          if (self._users[username] === void 0) {
            resolve(null);
          } else if (self._users[username][key] !== void 0) {
            resolve(self._users[username][key]);
          } else {
            resolve("undefined");
          }
        });
      }
      async getAny(username) {
        var self = this;
        return new Promise((resolve, reject) => {
          if (self._users[username] === void 0) {
            resolve(null);
          } else {
            resolve(utils.clone(self._users[username]));
          }
        });
      }
      async getAll() {
        var self = this;
        return new Promise((resolve, reject) => {
          resolve(utils.clone(self._users));
        });
      }
      async reset(username) {
        var self = this;
        return new Promise((resolve, reject) => {
          if (self._users[username] !== void 0) {
            delete self._users[username];
          }
          if (self._frozen[username] !== void 0) {
            delete self._frozen[username];
          }
          resolve();
        });
      }
      async resetAll() {
        var self = this;
        return new Promise((resolve, reject) => {
          self._users = {};
          self._frozen = {};
          resolve();
        });
      }
      async freeze(username) {
        var self = this;
        return new Promise((resolve, reject) => {
          if (self._users[username] !== void 0) {
            self._frozen[username] = utils.clone(self._users[username]);
            resolve();
          } else {
            reject(`freeze(${username}): user not found`);
          }
        });
      }
      async thaw(username, action = "thaw") {
        var self = this;
        return new Promise((resolve, reject) => {
          if (self._frozen[username] !== void 0) {
            switch (action) {
              case "thaw":
                self._users[username] = utils.clone(self._frozen[username]);
                delete self._frozen[username];
                break;
              case "discard":
                delete self._frozen[username];
                break;
              case "keep":
                self._users[username] = utils.clone(self._frozen[username]);
                break;
              default:
                reject("bad thaw action");
            }
            resolve();
          } else {
            reject(`thaw(${username}): no frozen variables found`);
          }
        });
      }
    };
    var NullSessionManager = class extends SessionManager {
      async set(username, data) {
        return noop();
      }
      async get(username, key) {
        return noop("undefined");
      }
      async getAny(username) {
        return noop(null);
      }
      async getAll() {
        return noop(new Object());
      }
      async reset(username) {
        return noop();
      }
      async resetAll() {
        return noop();
      }
      async freeze(username) {
        return noop();
      }
      async thaw(username, action) {
        return noop();
      }
    };
    async function noop(resp) {
      return new Promise((resolve, reject) => {
        resolve(resp);
      });
    }
    module2.exports.SessionManager = SessionManager;
    module2.exports.MemorySessionManager = MemorySessionManager;
    module2.exports.NullSessionManager = NullSessionManager;
  }
});

// node_modules/rivescript/src/lang/javascript.js
var require_javascript = __commonJS({
  "node_modules/rivescript/src/lang/javascript.js"(exports, module) {
    "use strict";
    var JSObjectHandler;
    JSObjectHandler = class JSObjectHandler {
      constructor(master) {
        this._master = master;
        this._objects = {};
        this._async = "";
        try {
          eval("(async function() {})");
          this._async = "async ";
        } catch (e2) {
        }
      }
      /**
      	void load (string name, string[]|function code)
      
      	Called by the RiveScript object to load JavaScript code.
      	*/
      load(name, code) {
        var e, source;
        if (typeof code === "function") {
          return this._objects[name] = code;
        } else {
          source = `this._objects["${name}"] = ${this._async}function(rs, args) {
${code.join("\n")}
};
`;
          try {
            return eval(source);
          } catch (error) {
            e = error;
            return this._master.warn("Error evaluating JavaScript object: " + e.message);
          }
        }
      }
      /**
      	string call (RiveScript rs, string name, string[] fields)
      
      	Called by the RiveScript object to execute JavaScript code.
      	*/
      call(rs, name2, fields, scope) {
        var e2, func, reply;
        if (!this._objects[name2]) {
          return this._master.errors.objectNotFound;
        }
        func = this._objects[name2];
        reply = "";
        try {
          reply = func.call(scope, rs, fields);
        } catch (error) {
          e2 = error;
          reply = `[ERR: Error when executing JavaScript object: ${e2.message}]`;
        }
        if (reply === void 0) {
          reply = "";
        }
        return reply;
      }
    };
    module.exports = JSObjectHandler;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/fs-readdir-recursive/index.js
var require_fs_readdir_recursive = __commonJS({
  "node_modules/fs-readdir-recursive/index.js"(exports2, module2) {
    var fs = require_fs();
    var path = require_path();
    module2.exports = read;
    function read(root, filter, files, prefix) {
      prefix = prefix || "";
      files = files || [];
      filter = filter || noDotFiles;
      var dir = path.join(root, prefix);
      if (!fs.existsSync(dir))
        return files;
      if (fs.statSync(dir).isDirectory())
        fs.readdirSync(dir).filter(function(name2, index) {
          return filter(name2, index, dir);
        }).forEach(function(name2) {
          read(root, filter, files, path.join(prefix, name2));
        });
      else
        files.push(prefix);
      return files;
    }
    function noDotFiles(x) {
      return x[0] !== ".";
    }
  }
});

// node_modules/rivescript/src/rivescript.js
var require_rivescript = __commonJS({
  "node_modules/rivescript/src/rivescript.js"(exports2, module2) {
    var VERSION = "2.2.1";
    var Parser = require_parser();
    var Brain = require_brain();
    var utils = require_utils();
    var sorting = require_sorting();
    var inherit_utils = require_inheritance();
    var { MemorySessionManager } = require_sessions();
    var JSObjectHandler2 = require_javascript();
    var readDir = require_fs_readdir_recursive();
    var RiveScript = function() {
      class RiveScript2 {
        ////////////////////////////////////////////////////////////////////////
        // Constructor and Debug Methods                                      //
        ////////////////////////////////////////////////////////////////////////
        constructor(opts) {
          var self = this;
          if (opts == null) {
            opts = {};
          }
          self._debug = opts.debug ? opts.debug : false;
          self._strict = opts.strict ? opts.strict : true;
          self._depth = opts.depth ? parseInt(opts.depth) : 50;
          self._utf8 = opts.utf8 ? opts.utf8 : false;
          self._forceCase = opts.forceCase ? opts.forceCase : false;
          self._onDebug = opts.onDebug ? opts.onDebug : null;
          self._concat = opts.concat ? opts.concat : null;
          self._caseSensitive = opts.caseSensitive ? opts.caseSensitive : false;
          self.unicodePunctuation = opts.unicodePunctuation ? opts.unicodePunctuation : new RegExp(/[.,!?;:]/g);
          self.errors = {
            replyNotMatched: "ERR: No Reply Matched",
            replyNotFound: "ERR: No Reply Found",
            objectNotFound: "[ERR: Object Not Found]",
            deepRecursion: "ERR: Deep Recursion Detected"
          };
          if (typeof opts.errors === "object") {
            let ref = opts.errors;
            for (let key in ref) {
              let value = ref[key];
              if (opts.errors.hasOwnProperty(key)) {
                self.errors[key] = value;
              }
            }
          }
          self._node = {};
          self._runtime = self.runtime();
          self.parser = new Parser(self);
          self.brain = new Brain(self);
          self._pending = [];
          self._loadCount = 0;
          self._global = {};
          self._var = {};
          self._sub = {};
          self._submax = 1;
          self._person = {};
          self._personmax = 1;
          self._array = {};
          self._session = null;
          self._includes = {};
          self._inherits = {};
          self._handlers = {};
          self._objlangs = {};
          self._topics = {};
          self._thats = {};
          self._sorted = {};
          if (typeof opts === "object") {
            if (opts.debug) {
              self._debug = true;
            }
            if (opts.strict) {
              self._strict = true;
            }
            if (opts.depth) {
              self._depth = parseInt(opts.depth);
            }
            if (opts.utf8) {
              self._utf8 = true;
            }
            if (opts.sessionManager) {
              self._session = opts.sessionManager;
            }
          }
          if (self._session === null) {
            self._session = new MemorySessionManager();
          }
          self._handlers.javascript = new JSObjectHandler2(self);
          self.say(`RiveScript Interpreter v${VERSION} Initialized.`);
          self.say(`Runtime Environment: ${self._runtime}`);
        }
        /**
        		string version ()
        
        		Returns the version number of the RiveScript.js library.
        		*/
        version() {
          return VERSION;
        }
        /**
        		private void runtime ()
        
        		Detect the runtime environment of this module, to determine if we're
        		running in a web browser or from node.
        		*/
        runtime() {
          var self = this;
          if (process.browser) {
            return "web";
          }
          self._node.fs = require_fs();
          return "node";
        }
        /**
        		private void say (string message)
        
        		This is the debug function. If debug mode is enabled, the 'message' will be
        		sent to the console via console.log (if available), or to your `onDebug`
        		handler if you defined one.
        		*/
        say(message) {
          var self = this;
          if (self._debug !== true) {
            return;
          }
          if (self._onDebug) {
            return self._onDebug(message);
          } else {
            return console.log(message);
          }
        }
        /**
        		private void warn (string message[, filename, lineno])
        
        		Print a warning or error message. This is like debug, except it's GOING to
        		be given to the user one way or another. If the `onDebug` handler is
        		defined, this is sent there. If `console` is available, this will be sent
        		there. In a worst case scenario, an alert box is shown.
        		*/
        warn(message, filename, lineno) {
          var self = this;
          if (filename != null && lineno != null) {
            message += ` at ${filename} line ${lineno}`;
          }
          if (self._onDebug) {
            return self._onDebug(`[WARNING] ${message}`);
          } else if (console) {
            if (console.error) {
              return console.error(message);
            } else {
              return console.log(`[WARNING] ${message}`);
            }
          } else if (window) {
            return window.alert(message);
          }
        }
        ////////////////////////////////////////////////////////////////////////
        // Loading and Parsing Methods                                        //
        ////////////////////////////////////////////////////////////////////////
        /**
        		async loadFile(string path || array path)
        
        		Load a RiveScript document from a file. The path can either be a string that
        		contains the path to a single file, or an array of paths to load multiple
        		files. The Promise resolves when all of the files have been parsed and
        		loaded. The Promise rejects on error.
        
        		This loading method is asynchronous so you must resolve the promise or
        		await it before you go on to sort the replies.
        
        		For backwards compatibility, this function can take callbacks instead
        		of returning a Promise:
        
        		> `rs.loadDirectory(path, onSuccess(), onError(err, filename, lineno))`
        
        		* resolves: `()`
        		* rejects: `(string error)`
        		*/
        async loadFile(path, onSuccess, onError) {
          var self = this;
          if (typeof path === "string") {
            path = [path];
          }
          let promises = new Array();
          for (let i = 0, len = path.length; i < len; i++) {
            let file = path[i];
            self.say(`Request to load file: ${file}`);
            promises.push(function(f) {
              if (self._runtime === "web") {
                return self._ajaxLoadFile(f);
              } else {
                return self._nodeLoadFile(f);
              }
            }(file));
          }
          let promise = new Promise((resolve, reject) => {
            Promise.all(promises).then(resolve).catch(reject);
          });
          if (typeof onSuccess === "function") {
            self.warn("DEPRECATED: RiveScript.loadFile() now returns a Promise instead of using callbacks");
            return promise.then(onSuccess).catch(function(err, filename, lineno) {
              if (typeof onError === "function") {
                onError.call(null, err, filename, lineno);
              }
            });
          } else {
            return promise;
          }
        }
        // Load a file using ajax. DO NOT CALL THIS DIRECTLY.
        // Returns a Promise.
        async _ajaxLoadFile(file) {
          var self = this;
          return new Promise(function(resolve, reject) {
            let xhr = new XMLHttpRequest();
            xhr.open("GET", file, true);
            xhr.onreadystatechange = () => {
              var ref;
              if (xhr.readyState === 4) {
                let ref2 = xhr.status;
                if (ref2 === 200) {
                  self.say(`Loading file ${file} complete.`);
                  let ok = self.parse(file, xhr.responseText, (err) => {
                    reject(err);
                  });
                  if (ok) {
                    resolve();
                  } else {
                    reject("parser error");
                  }
                } else {
                  self.warn(`Network error in XMLHttpRequest for file ${file}`);
                  reject(`Failed to load file ${file}: network error`);
                }
              }
            };
            xhr.send(null);
          });
        }
        // Load a file using node. DO NOT CALL THIS DIRECTLY.
        // Returns a Promise.
        async _nodeLoadFile(file) {
          var self = this;
          return new Promise(function(resolve, reject) {
            return self._node.fs.readFile(file, (err, data) => {
              if (err) {
                reject(err);
                return;
              }
              let ok = self.parse(file, "" + data, (err2) => {
                reject(err2);
              });
              if (ok) {
                resolve();
              } else {
                reject("parser error");
              }
            });
          });
        }
        /**
        		async loadDirectory (string path)
        
        		Load RiveScript documents from a directory recursively.
        
        		For backwards compatibility, this function can take callbacks instead
        		of returning a Promise:
        
        		> `rs.loadDirectory(path, onSuccess(), onError(err, filename, lineno))`
        
        		This function is not supported in a web environment.
        		*/
        async loadDirectory(path, onSuccess, onError) {
          var self = this;
          var promise = new Promise(function(resolve, reject) {
            if (self._runtime === "web") {
              reject("loadDirectory can't be used on the web!");
              return;
            }
            self._node.fs.stat(path, (err, stats) => {
              if (err) {
                reject(err);
                return;
              }
              if (!stats.isDirectory()) {
                reject(`${path} is not a directory`);
                return;
              }
              self.say(`Loading from directory ${path}`);
              let files = readDir(path);
              let toLoad = new Array();
              for (let i = 0, len = files.length; i < len; i++) {
                let file = files[i];
                if (file.match(/\.(rive|rs)$/i)) {
                  toLoad.push(path + "/" + file);
                }
              }
              self.loadFile(toLoad).then(resolve).catch(reject);
            });
          });
          if (typeof onSuccess === "function") {
            self.warn("DEPRECATED: RiveScript.loadDirectory() now returns a Promise instead of using callbacks");
            return promise.then(onSuccess).catch(function(err, filename, lineno) {
              if (typeof onError === "function") {
                onError.call(null, err, filename, lineno);
              }
            });
          }
          return promise;
        }
        /**
        		bool stream (string code[, func onError])
        
        		Load RiveScript source code from a string. `code` should be the raw
        		RiveScript source code, with line breaks separating each line.
        
        		This function is synchronous, meaning it does not return a Promise. It
        		parses the code immediately and returns. Do not fear: the parser runs
        		very quickly.
        
        		Returns `true` if the code parsed with no error.
        
        		onError function receives: `(err string[, filename str, line_no int])`
        		*/
        stream(code2, onError) {
          var self = this;
          return self.parse("stream()", code2, onError);
        }
        /**
        		private bool parse (string name, string code[, func onError(string)])
        
        		Parse RiveScript code and load it into memory. `name` is a file name in case
        		syntax errors need to be pointed out. `code` is the source code.
        
        		Returns `true` if the code parsed with no error.
        		*/
        parse(filename, code2, onError) {
          var self = this;
          self.say("Parsing code!");
          let ok = true;
          let ast = self.parser.parse(filename, code2, (err, fn, ln) => {
            if (typeof onError === "function") {
              onError.call(null, err, fn, ln);
            }
            ok = false;
          });
          for (let type in ast.begin) {
            let vars = ast.begin[type];
            if (!ast.begin.hasOwnProperty(type)) {
              continue;
            }
            let internal = `_${type}`;
            for (let name2 in vars) {
              let value = vars[name2];
              if (type === "sub" || type === "person") {
                self[internal + "max"] = Math.max(self[internal + "max"], name2.split(" ").length);
              }
              if (!vars.hasOwnProperty(name2)) {
                continue;
              }
              if (value === "<undef>") {
                delete self[internal][name2];
              } else {
                self[internal][name2] = value;
              }
            }
          }
          if (self._global.debug != null) {
            self._debug = self._global.debug === "true";
          }
          if (self._global.depth != null) {
            self._depth = parseInt(self._global.depth) || 50;
          }
          for (let topic in ast.topics) {
            let data = ast.topics[topic];
            if (!ast.topics.hasOwnProperty(topic)) {
              continue;
            }
            if (self._includes[topic] == null) {
              self._includes[topic] = {};
            }
            if (self._inherits[topic] == null) {
              self._inherits[topic] = {};
            }
            utils.extend(self._includes[topic], data.includes);
            utils.extend(self._inherits[topic], data.inherits);
            if (self._topics[topic] == null) {
              self._topics[topic] = [];
            }
            for (let i = 0, len = data.triggers.length; i < len; i++) {
              let trigger = data.triggers[i];
              self._topics[topic].push(trigger);
              if (trigger.previous != null) {
                if (self._thats[topic] == null) {
                  self._thats[topic] = {};
                }
                if (self._thats[topic][trigger.trigger] == null) {
                  self._thats[topic][trigger.trigger] = {};
                }
                self._thats[topic][trigger.trigger][trigger.previous] = trigger;
              }
            }
          }
          let results = [];
          for (let j = 0, len = ast.objects.length; j < len; j++) {
            let object = ast.objects[j];
            if (self._handlers[object.language]) {
              self._objlangs[object.name] = object.language;
              results.push(self._handlers[object.language].load(object.name, object.code));
            }
          }
          return ok;
        }
        /**
        		void sortReplies()
        
        		After you have finished loading your RiveScript code, call this method to
        		populate the various sort buffers. This is absolutely necessary for reply
        		matching to work efficiently!
        		*/
        sortReplies() {
          var self = this;
          self._sorted.topics = {};
          self._sorted.thats = {};
          self.say("Sorting triggers...");
          for (let topic in self._topics) {
            if (!self._topics.hasOwnProperty(topic)) {
              continue;
            }
            self.say(`Analyzing topic ${topic}...`);
            let allTriggers = inherit_utils.getTopicTriggers(self, topic);
            self._sorted.topics[topic] = sorting.sortTriggerSet(allTriggers, true);
            let thatTriggers = inherit_utils.getTopicTriggers(self, topic, true);
            self._sorted.thats[topic] = sorting.sortTriggerSet(thatTriggers, false);
          }
          self._sorted.sub = sorting.sortList(Object.keys(self._sub));
          return self._sorted.person = sorting.sortList(Object.keys(self._person));
        }
        /**
        		data deparse()
        
        		Translate the in-memory representation of the loaded RiveScript documents
        		into a JSON-serializable data structure. This may be useful for developing
        		a user interface to edit RiveScript replies without having to edit the
        		RiveScript code manually, in conjunction with the `write()` method.
        
        		The format of the deparsed data structure is out of scope for this document,
        		but there is additional information and examples available in the `eg/`
        		directory of the source distribution. You can read the documentation on
        		GitHub here: [RiveScript Deparse](https://github.com/aichaos/rivescript-js/tree/master/eg/deparse)
        		*/
        deparse() {
          var self = this;
          let result = {
            begin: {
              global: utils.clone(self._global),
              var: utils.clone(self._var),
              sub: utils.clone(self._sub),
              person: utils.clone(self._person),
              array: utils.clone(self._array),
              triggers: []
            },
            topics: utils.clone(self._topics),
            inherits: utils.clone(self._inherits),
            includes: utils.clone(self._includes),
            objects: {}
          };
          for (let key in self._handlers) {
            result.objects[key] = {
              _objects: utils.clone(self._handlers[key]._objects)
            };
          }
          if (result.topics.__begin__ != null) {
            result.begin.triggers = result.topics.__begin__;
            delete result.topics.__begin__;
          }
          if (self._debug) {
            result.begin.global.debug = self._debug;
          }
          if (self._depth !== 50) {
            result.begin.global.depth = self._depth;
          }
          return result;
        }
        /**
        		string stringify([data deparsed])
        
        		Translate the in-memory representation of the RiveScript brain back into
        		RiveScript source code. This is like `write()`, but it returns the text of
        		the source code as a string instead of writing it to a file.
        
        		You can optionally pass the parameter `deparsed`, which should be a data
        		structure of the same format that the `deparse()` method returns. If not
        		provided, the current internal data is used (this function calls `deparse()`
        		itself and uses that).
        
        		Warning: the output of this function won't be pretty. For example, no word
        		wrapping will be done for your longer replies. The only guarantee is that
        		what comes out of this function is valid RiveScript code that can be loaded
        		back in later.
        		*/
        stringify(deparsed) {
          var self = this;
          return self.parser.stringify(deparsed);
        }
        /**
        		void write (string filename[, data deparsed])
        
        		Write the in-memory RiveScript data into a RiveScript text file. This
        		method can not be used on the web; it requires filesystem access and can
        		only run from a Node environment.
        
        		This calls the `stringify()` method and writes the output into the filename
        		specified. You can provide your own deparse-compatible data structure,
        		or else the current state of the bot's brain is used instead.
        		*/
        write(filename, deparsed) {
          var self = this;
          if (self._runtime === "web") {
            self.warn("write() can't be used on the web!");
            return;
          }
          return self._node.fs.writeFile(filename, self.stringify(deparsed), function(err) {
            if (err) {
              return self.warn(`Error writing to file ${filename}: ${err}`);
            }
          });
        }
        ////////////////////////////////////////////////////////////////////////
        // Public Configuration Methods                                       //
        ////////////////////////////////////////////////////////////////////////
        /**
        		void setHandler(string lang, object)
        
        		Set a custom language handler for RiveScript object macros. See the source
        		for the built-in JavaScript handler (src/lang/javascript.coffee) as an
        		example.
        
        		By default, JavaScript object macros are enabled. If you want to disable
        		these (e.g. for security purposes when loading untrusted third-party code),
        		just set the JavaScript handler to null:
        
        		```javascript
        		var bot = new RiveScript();
        		bot.setHandler("javascript", null);
        		```
        		*/
        setHandler(lang, obj) {
          var self = this;
          if (obj === void 0) {
            return delete self._handlers[lang];
          } else {
            return self._handlers[lang] = obj;
          }
        }
        /**
        		void setSubroutine(string name, function)
        
        		Define a JavaScript object macro from your program.
        
        		This is equivalent to having a JS object defined in the RiveScript code,
        		except your JavaScript code is defining it instead.
        		*/
        setSubroutine(name2, code2) {
          var self = this;
          if (self._handlers.javascript) {
            self._objlangs[name2] = "javascript";
            return self._handlers.javascript.load(name2, code2);
          }
        }
        /**
        		void setGlobal (string name, string value)
        
        		Set a global variable. This is equivalent to `! global` in RiveScript.
        		Set the value to `undefined` to delete a global.
        		*/
        setGlobal(name2, value) {
          var self = this;
          if (value === void 0) {
            return delete self._global[name2];
          } else {
            return self._global[name2] = value;
          }
        }
        /**
        		void setVariable (string name, string value)
        
        		Set a bot variable. This is equivalent to `! var` in RiveScript.
        		Set the value to `undefined` to delete a bot variable.
        		*/
        setVariable(name2, value) {
          var self = this;
          if (value === void 0) {
            return delete self._var[name2];
          } else {
            return self._var[name2] = value;
          }
        }
        /**
        		void setSubstitution (string name, string value)
        
        		Set a substitution. This is equivalent to `! sub` in RiveScript.
        		Set the value to `undefined` to delete a substitution.
        		*/
        setSubstitution(name2, value) {
          var self = this;
          if (value === void 0) {
            return delete self._sub[name2];
          } else {
            self._submax = Math.max(name2.split(" ").length, self._submax);
            return self._sub[name2] = value;
          }
        }
        /**
        		void setPerson (string name, string value)
        
        		Set a person substitution. This is equivalent to `! person` in RiveScript.
        		Set the value to `undefined` to delete a person substitution.
        		*/
        setPerson(name2, value) {
          var self = this;
          if (value === void 0) {
            return delete self._person[name2];
          } else {
            self._personmax = Math.max(name2.split(" ").length, self._personmax);
            return self._person[name2] = value;
          }
        }
        /**
        		async setUservar (string user, string name, string value)
        
        		Set a user variable for a user.
        		*/
        async setUservar(user, name2, value) {
          var self = this;
          if (name2 === "topic" && self._forceCase) {
            value = value.toLowerCase();
          }
          var fields = {};
          fields[name2] = value;
          return self._session.set(user, fields);
        }
        /**
        		async setUservars (string user, object data)
        
        		Set multiple user variables by providing an object of key/value pairs.
        		Equivalent to calling `setUservar()` for each pair in the object.
        		*/
        async setUservars(user, data) {
          var self = this;
          return self._session.set(user, data);
        }
        /**
        		string getVariable (string name)
        
        		Gets a variable. This is equivalent to `<bot name>` in RiveScript.
        		*/
        getVariable(name2) {
          var self = this;
          if (typeof self._var[name2] !== "undefined") {
            return self._var[name2];
          } else {
            return "undefined";
          }
        }
        /**
        		async getUservar (string user, string name) -> value
        
        		Get a variable from a user. Returns the string "undefined" if it isn't
        		defined.
        		*/
        async getUservar(user, name2) {
          var self = this;
          return self._session.get(user, name2);
        }
        /**
        		async getUservars ([string user]) -> object
        
        		Get all variables about a user. If no user is provided, returns all data
        		about all users.
        		*/
        async getUservars(user) {
          var self = this;
          if (user === void 0) {
            return self._session.getAll();
          } else {
            return self._session.getAny(user);
          }
        }
        /**
        		async clearUservars ([string user])
        
        		Clear all a user's variables. If no user is provided, clears all variables
        		for all users.
        		*/
        async clearUservars(user) {
          var self = this;
          if (user === void 0) {
            return self._session.resetAll();
          } else {
            return self._session.reset(user);
          }
        }
        /**
        		async freezeUservars (string user)
        
        		Freeze the variable state of a user. This will clone and preserve the user's
        		entire variable state, so that it can be restored later with
        		`thawUservars()`
        		*/
        async freezeUservars(user) {
          var self = this;
          return self._session.freeze(user);
        }
        /**
        		async thawUservars (string user[, string action])
        
        		Thaw a user's frozen variables. The action can be one of the following:
        		* discard: Don't restore the variables, just delete the frozen copy.
        		* keep: Keep the frozen copy after restoring
        		* thaw: Restore the variables and delete the frozen copy (default)
        		*/
        async thawUservars(user, action = "thaw") {
          var self = this;
          return self._session.thaw(user, action);
        }
        /**
        		async lastMatch (string user) -> string
        
        		Retrieve the trigger that the user matched most recently.
        		*/
        async lastMatch(user) {
          var self = this;
          return self._session.get(user, "__lastmatch__");
        }
        /**
        		async initialMatch (string user) -> string
        
        		Retrieve the trigger that the user matched initially. This will return
        		only the first matched trigger and will not include subsequent redirects.
        
        		This value is reset on each `reply()` call.
        		*/
        async initialMatch(user) {
          var self = this;
          return self._session.get(user, "__initialmatch__");
        }
        /**
        		async lastTriggers (string user) -> object
        
        		Retrieve the triggers that have been matched for the last reply. This
        		will contain all matched trigger with every subsequent redirects.
        
        		This value is reset on each `reply()` or `replyAsync()` call.
        		*/
        async lastTriggers(user) {
          var self = this;
          return self._session.get(user, "__last_triggers__");
        }
        /**
        		async getUserTopicTriggers (string username) -> object
        
        		Retrieve the triggers in the current topic for the specified user. It can
        		be used to create a UI that gives the user options based on trigges, e.g.
        		using buttons, select boxes and other UI resources. This also includes the
        		triggers available in any topics inherited or included by the user's current
        		topic.
        
        		This will return `undefined` if the user cant be find
        		*/
        async getUserTopicTriggers(user) {
          var self = this;
          return new Promise((resolve, reject) => {
            self._session.get(user, "topic").then((topic) => {
              resolve(inherit_utils.getTopicTriggers(self, topic));
            });
          });
        }
        /**
        		string currentUser ()
        
        		Retrieve the current user's ID. This is most useful within a JavaScript
        		object macro to get the ID of the user who invoked the macro (e.g. to
        		get/set user variables for them).
        
        		This will return undefined if called from outside of a reply context
        		(the value is unset at the end of the `reply()` method)
        		*/
        currentUser() {
          var self = this;
          if (self.brain._currentUser === null) {
            self.warn("currentUser() is intended to be called from within a JS object macro!");
          }
          return self.brain._currentUser;
        }
        ////////////////////////////////////////////////////////////////////////
        // Reply Fetching Methods                                             //
        ////////////////////////////////////////////////////////////////////////
        /**
        		Promise reply (string username, string message[, scope])
        
        		Fetch a reply from the RiveScript brain. The message doesn't require any
        		special pre-processing to be done to it, i.e. it's allowed to contain
        		punctuation and weird symbols. The username is arbitrary and is used to
        		uniquely identify the user, in the case that you may have multiple
        		distinct users chatting with your bot.
        
        		**Changed in version 2.0.0:** this function used to return a string, but
        		therefore didn't support async object macros or session managers. This
        		function now returns a Promise (obsoleting the `replyAsync()` function).
        
        		The optional `scope` parameter will be passed down into any JavaScript
        		object macros that the RiveScript code executes. If you pass the special
        		variable `this` as the scope parameter, then `this` in the context of an
        		object macro will refer to the very same `this` as the one you passed in,
        		so for example the object macro will have access to any local functions
        		or attributes that your code has access to, from the location that `reply()`
        		was called. For an example of this, refer to the `eg/scope` directory in
        		the source distribution of RiveScript-JS.
        
        		Example:
        
        		```javascript
        		// Normal usage as a promise
        		bot.reply(username, message, this).then(function(reply) {
        			console.log("Bot>", reply);
        		});
        
        		// Async-Await usage in an async function.
        		async function getReply(username, message) {
        			var reply = await bot.reply(username, message);
        			console.log("Bot>", reply);
        		}
        		```
        		*/
        async reply(user, msg, scope) {
          var self = this;
          return await self.brain.reply(user, msg, scope);
        }
        /**
        		Promise replyAsync (string username, string message [[, scope], callback])
        
        		**Obsolete as of v2.0.0** -- use `reply()` instead in new code.
        
        		Asyncronous version of reply. Use replyAsync if at least one of the subroutines
        		used with the `<call>` tag returns a promise.
        
        		Example: using promises
        
        		```javascript
        		rs.replyAsync(user, message).then(function(reply) {
        		  console.log("Bot>", reply);
        		}).catch(function(error) {
        		  console.error("Error: ", error);
        		});
        		```
        
        		Example: using the callback
        
        		```javascript
        		rs.replyAsync(username, msg, this, function(error, reply) {
        		  if (!error) {
        			console.log("Bot>", reply);
        		  } else {
        			console.error("Error: ", error);
        		  }
        		});
        		```
        		*/
        replyAsync(user, msg, scope, callback) {
          var self = this;
          self.warn("DEPRECATED FUNCTION: RiveScript.replyAsync() is deprecated; use reply() instead");
          let reply = self.brain.reply(user, msg, scope);
          if (callback) {
            reply.then((result) => {
              return callback.call(self, null, result);
            }).catch((error) => {
              return callback.call(self, error, null);
            });
          }
          return reply;
        }
      }
      ;
      RiveScript2.prototype.Promise = Promise;
      return RiveScript2;
    }();
    module2.exports = RiveScript;
  }
});
export default require_rivescript();
//# sourceMappingURL=rivescript.js.map
